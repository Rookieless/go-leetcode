////////假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
////////
//////// 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
////////
////////
////////
//////// 示例 1：
////////
////////
////////输入：n = 2
////////输出：2
////////解释：有两种方法可以爬到楼顶。
////////1. 1 阶 + 1 阶
////////2. 2 阶
////////
//////// 示例 2：
////////
////////
////////输入：n = 3
////////输出：3
////////解释：有三种方法可以爬到楼顶。
////////1. 1 阶 + 1 阶 + 1 阶
////////2. 1 阶 + 2 阶
////////3. 2 阶 + 1 阶
////////
////////
////////
////////
//////// 提示：
////////
////////
//////// 1 <= n <= 45
////////
//////// Related Topics 记忆化搜索 数学 动态规划 👍 2511 👎 0
//////
////
//

package main

import "fmt"

func main() {
	result := climbStairs(4)
	fmt.Println(result)
}

//leetcode submit region begin(Prohibit modification and deletion)
func climbStairs(n int) int {
	if n == 1 {
		return 1
	}
	if n == 2 {
		return 2
	}
	a, b := 1, 2
	for i := 3; i <= n; i++ {
		a, b = b, b+a
	}
	return b
}

//leetcode submit region end(Prohibit modification and deletion)

/*
	先分析状态转移方程:
	 已知: f[1], f[2] = 1 ,2
     当n阶台阶的时候,最后一步可能是一次上两个台阶,也可能是一次上一个台阶,所以可以很简单的判断
     f(n) = f(n-1) + f(n-2)

	1.这里面显然会有很多重复子问题,选择dptable 的方式优化,
	2.在判断每次用到的数据只有n-1和n-2,自然想到用滑动数组的方式优化
*/
